from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import List, Optional
from bson import ObjectId
from datetime import datetime

from models.category_schemas import CategoryCreate, CategoryInDBBase, CategoryUpdate
from models.user_schemas import PyObjectId # Assuming PyObjectId is correctly defined and used

# Name of the MongoDB collection for categories
CATEGORIES_COLLECTION = "categories"
BOOKS_COLLECTION = "books"

async def create_category(
    db: AsyncIOMotorDatabase, 
    category_in: CategoryCreate, 
    user_id: PyObjectId
) -> CategoryInDBBase:
    """
    Creates a new category for a user.
    Checks for duplicate category names for the same user (case-insensitive).
    """
    # Check if category with the same name already exists for this user (case-insensitive)
    existing_category = await db[CATEGORIES_COLLECTION].find_one(
        {"user_id": user_id, "name": {"$regex": f"^{category_in.name}$", "$options": "i"}}
    )
    if existing_category:
        raise ValueError(f"Category with name '{category_in.name}' already exists for this user.")

    category_doc = CategoryInDBBase(
        name=category_in.name,
        user_id=user_id,
        created_at=datetime.utcnow() 
        # id will be generated by default_factory if not provided, or by MongoDB if not in Pydantic model upon insert
    )
    
    # Pydantic v2 .model_dump() is preferred over .dict()
    category_dict_for_db = category_doc.model_dump(by_alias=True, exclude_none=True)
    
    # Manually remove 'id' if it's None to let MongoDB generate it,
    # or ensure your Pydantic model's default_factory for id works as expected.
    if category_dict_for_db.get("_id") is None:
        category_dict_for_db.pop("_id", None)


    result = await db[CATEGORIES_COLLECTION].insert_one(category_dict_for_db)
    
    created_category_doc = await db[CATEGORIES_COLLECTION].find_one({"_id": result.inserted_id})
    if not created_category_doc:
        # This would be unusual if insert_one succeeded
        raise Exception("Failed to retrieve category after creation.")
        
    return CategoryInDBBase(**created_category_doc)

async def get_categories_by_user(
    db: AsyncIOMotorDatabase, 
    user_id: PyObjectId
) -> List[CategoryInDBBase]:
    """
    Retrieves all categories for a specific user, sorted by creation date.
    """
    categories_cursor = db[CATEGORIES_COLLECTION].find({"user_id": user_id}).sort("created_at", 1) # Sort by oldest first, or -1 for newest
    db_categories = await categories_cursor.to_list(length=None) # Fetch all
    return [CategoryInDBBase(**cat_doc) for cat_doc in db_categories]

async def get_category_by_id_for_user(
    db: AsyncIOMotorDatabase, 
    category_id_str: str, 
    user_id: PyObjectId
) -> Optional[CategoryInDBBase]:
    """
    Retrieves a specific category by its ID, ensuring it belongs to the user.
    """
    try:
        category_oid = PyObjectId(category_id_str) # Validate and convert string ID
    except Exception: # Catch errors from PyObjectId validation (e.g., invalid format)
        return None 
        
    category_doc = await db[CATEGORIES_COLLECTION].find_one({"_id": category_oid, "user_id": user_id})
    if category_doc:
        return CategoryInDBBase(**category_doc)
    return None

async def update_category_name(
    db: AsyncIOMotorDatabase, 
    category_id_str: str, 
    category_update: CategoryUpdate, 
    user_id: PyObjectId
) -> Optional[CategoryInDBBase]:
    """
    Updates the name of a category.
    Ensures the new name isn't a duplicate for the same user (excluding the current category being updated).
    """
    category_to_update = await get_category_by_id_for_user(db, category_id_str, user_id)
    if not category_to_update:
        return None # Category not found or doesn't belong to user

    # Check if another category with the new name already exists for this user
    existing_category_with_new_name = await db[CATEGORIES_COLLECTION].find_one(
        {
            "user_id": user_id, 
            "name": {"$regex": f"^{category_update.name}$", "$options": "i"},
            "_id": {"$ne": category_to_update.id} # Exclude the current category itself
        }
    )
    if existing_category_with_new_name:
        raise ValueError(f"Another category with name '{category_update.name}' already exists for this user.")

    update_data = {"$set": {"name": category_update.name}}
    # Optional: add updated_at field: 
    # update_data["$set"]["updated_at"] = datetime.utcnow() 

    await db[CATEGORIES_COLLECTION].update_one(
        {"_id": category_to_update.id, "user_id": user_id}, 
        update_data
    )
    
    updated_category_doc = await db[CATEGORIES_COLLECTION].find_one({"_id": category_to_update.id})
    if updated_category_doc:
        return CategoryInDBBase(**updated_category_doc)
    return None # Should not happen if update was successful and ID is correct

async def delete_category_for_user(
    db: AsyncIOMotorDatabase, 
    category_id_str: str, 
    user_id: PyObjectId
) -> bool:
    """
    Deletes a category for a user.
    Also updates books in this category to be uncategorized (sets their category_id to null).
    """
    category_to_delete = await get_category_by_id_for_user(db, category_id_str, user_id)
    if not category_to_delete:
        return False # Category not found or doesn't belong to user

    # Set category_id to null for all books of this user that were in this category
    await db[BOOKS_COLLECTION].update_many(
        {"user_id": user_id, "category_id": category_to_delete.id},
        {"$set": {"category_id": None}} 
        # Or {"$unset": {"category_id": ""}} if you prefer to remove the field
    )

    delete_result = await db[CATEGORIES_COLLECTION].delete_one(
        {"_id": category_to_delete.id, "user_id": user_id}
    )
    
    return delete_result.deleted_count > 0